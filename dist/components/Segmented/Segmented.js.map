{"version":3,"file":"Segmented.js","sources":["../../../src/components/Segmented/Segmented.tsx"],"sourcesContent":["import type { ReactNode } from 'react';\nimport { useState } from 'react';\nimport styles from './Segmented.module.css';\n\nexport interface SegmentedOption {\n  /** Option value */\n  value: string;\n  /** Option label */\n  label: ReactNode;\n  /** Option icon */\n  icon?: ReactNode;\n  /** Disabled state */\n  disabled?: boolean;\n}\n\nexport interface SegmentedProps {\n  /** Available options */\n  options: SegmentedOption[];\n  /** Selected value (controlled) */\n  value?: string;\n  /** Default selected value (uncontrolled) */\n  defaultValue?: string;\n  /** Change handler */\n  onChange?: (value: string) => void;\n  /** Size variant */\n  size?: 'sm' | 'md' | 'lg';\n  /** Full width */\n  block?: boolean;\n  /** Icon only mode */\n  iconOnly?: boolean;\n  /** Disabled state */\n  disabled?: boolean;\n  /** ARIA label */\n  'aria-label'?: string;\n  /** Custom className */\n  className?: string;\n}\n\n/**\n * Segmented Component\n *\n * Compact single-select button group, visual alternative to radio buttons.\n * Ideal for view mode switching, time range selection, and status filtering.\n *\n * @example\n * ```tsx\n * <Segmented\n *   options={[\n *     { value: 'list', label: 'List', icon: <List /> },\n *     { value: 'grid', label: 'Grid', icon: <Grid /> },\n *     { value: 'table', label: 'Table', icon: <Table /> },\n *   ]}\n *   defaultValue=\"list\"\n *   onChange={(value) => console.log(value)}\n * />\n * ```\n *\n * @example\n * ```tsx\n * // Icon only\n * <Segmented\n *   options={[\n *     { value: 'list', icon: <List />, label: 'List view' },\n *     { value: 'grid', icon: <Grid />, label: 'Grid view' },\n *   ]}\n *   iconOnly\n *   defaultValue=\"list\"\n * />\n * ```\n */\nexport const Segmented = ({\n  options,\n  value: controlledValue,\n  defaultValue,\n  onChange,\n  size = 'md',\n  block = false,\n  iconOnly = false,\n  disabled = false,\n  'aria-label': ariaLabel,\n  className,\n}: SegmentedProps) => {\n  // Handle controlled/uncontrolled state\n  const [uncontrolledValue, setUncontrolledValue] = useState<string>(\n    defaultValue || options[0]?.value || ''\n  );\n\n  const selectedValue = controlledValue !== undefined ? controlledValue : uncontrolledValue;\n\n  const handleChange = (newValue: string) => {\n    if (controlledValue === undefined) {\n      setUncontrolledValue(newValue);\n    }\n    onChange?.(newValue);\n  };\n\n  const containerClasses = [\n    styles.segmented,\n    size === 'sm' && styles.segmentedSm,\n    size === 'lg' && styles.segmentedLg,\n    block && styles.segmentedBlock,\n    iconOnly && styles.segmentedIconOnly,\n    disabled && styles.segmentedDisabled,\n    className,\n  ]\n    .filter(Boolean)\n    .join(' ');\n\n  return (\n    <div className={containerClasses} role=\"radiogroup\" aria-label={ariaLabel}>\n      {options.map((option) => {\n        const isSelected = selectedValue === option.value;\n        const isDisabled = disabled || option.disabled;\n        const inputId = `segmented-${option.value}-${Math.random().toString(36).substr(2, 9)}`;\n\n        return (\n          <div key={option.value}>\n            <input\n              type=\"radio\"\n              id={inputId}\n              name=\"segmented\"\n              value={option.value}\n              checked={isSelected}\n              disabled={isDisabled}\n              onChange={() => handleChange(option.value)}\n              hidden\n            />\n            <label\n              htmlFor={inputId}\n              className={styles.segmentedItem}\n              aria-label={iconOnly ? (typeof option.label === 'string' ? option.label : undefined) : undefined}\n            >\n              {option.icon && <span className={styles.segmentedItemIcon}>{option.icon}</span>}\n              {!iconOnly && option.label && <span>{option.label}</span>}\n            </label>\n          </div>\n        );\n      })}\n    </div>\n  );\n};\n\nSegmented.displayName = 'Segmented';\n"],"names":["Segmented","options","controlledValue","defaultValue","onChange","size","block","iconOnly","disabled","ariaLabel","className","uncontrolledValue","setUncontrolledValue","useState","selectedValue","handleChange","newValue","containerClasses","styles","jsx","option","isSelected","isDisabled","inputId","jsxs"],"mappings":";;;AAsEO,MAAMA,IAAY,CAAC;AAAA,EACxB,SAAAC;AAAA,EACA,OAAOC;AAAA,EACP,cAAAC;AAAA,EACA,UAAAC;AAAA,EACA,MAAAC,IAAO;AAAA,EACP,OAAAC,IAAQ;AAAA,EACR,UAAAC,IAAW;AAAA,EACX,UAAAC,IAAW;AAAA,EACX,cAAcC;AAAA,EACd,WAAAC;AACF,MAAsB;AAEpB,QAAM,CAACC,GAAmBC,CAAoB,IAAIC;AAAA,IAChDV,KAAgBF,EAAQ,CAAC,GAAG,SAAS;AAAA,EAAA,GAGjCa,IAAgBZ,MAAoB,SAAYA,IAAkBS,GAElEI,IAAe,CAACC,MAAqB;AACzC,IAAId,MAAoB,UACtBU,EAAqBI,CAAQ,GAE/BZ,IAAWY,CAAQ;AAAA,EACrB,GAEMC,IAAmB;AAAA,IACvBC,EAAO;AAAA,IACPb,MAAS,QAAQa,EAAO;AAAA,IACxBb,MAAS,QAAQa,EAAO;AAAA,IACxBZ,KAASY,EAAO;AAAA,IAChBX,KAAYW,EAAO;AAAA,IACnBV,KAAYU,EAAO;AAAA,IACnBR;AAAA,EAAA,EAEC,OAAO,OAAO,EACd,KAAK,GAAG;AAEX,SACE,gBAAAS,EAAC,OAAA,EAAI,WAAWF,GAAkB,MAAK,cAAa,cAAYR,GAC7D,UAAAR,EAAQ,IAAI,CAACmB,MAAW;AACvB,UAAMC,IAAaP,MAAkBM,EAAO,OACtCE,IAAad,KAAYY,EAAO,UAChCG,IAAU,aAAaH,EAAO,KAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,GAAG,CAAC,CAAC;AAEpF,6BACG,OAAA,EACC,UAAA;AAAA,MAAA,gBAAAD;AAAA,QAAC;AAAA,QAAA;AAAA,UACC,MAAK;AAAA,UACL,IAAII;AAAA,UACJ,MAAK;AAAA,UACL,OAAOH,EAAO;AAAA,UACd,SAASC;AAAA,UACT,UAAUC;AAAA,UACV,UAAU,MAAMP,EAAaK,EAAO,KAAK;AAAA,UACzC,QAAM;AAAA,QAAA;AAAA,MAAA;AAAA,MAER,gBAAAI;AAAA,QAAC;AAAA,QAAA;AAAA,UACC,SAASD;AAAA,UACT,WAAWL,EAAO;AAAA,UAClB,cAAYX,KAAY,OAAOa,EAAO,SAAU,WAAWA,EAAO,QAAqB;AAAA,UAEtF,UAAA;AAAA,YAAAA,EAAO,QAAQ,gBAAAD,EAAC,QAAA,EAAK,WAAWD,EAAO,mBAAoB,YAAO,KAAA,CAAK;AAAA,YACvE,CAACX,KAAYa,EAAO,SAAS,gBAAAD,EAAC,QAAA,EAAM,YAAO,MAAA,CAAM;AAAA,UAAA;AAAA,QAAA;AAAA,MAAA;AAAA,IACpD,EAAA,GAlBQC,EAAO,KAmBjB;AAAA,EAEJ,CAAC,EAAA,CACH;AAEJ;AAEApB,EAAU,cAAc;"}