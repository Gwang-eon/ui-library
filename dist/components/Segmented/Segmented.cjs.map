{"version":3,"file":"Segmented.cjs","sources":["../../../src/components/Segmented/Segmented.tsx"],"sourcesContent":["import type { ReactNode } from 'react';\nimport { useState } from 'react';\nimport styles from './Segmented.module.css';\n\nexport interface SegmentedOption {\n  /** Option value */\n  value: string;\n  /** Option label */\n  label: ReactNode;\n  /** Option icon */\n  icon?: ReactNode;\n  /** Disabled state */\n  disabled?: boolean;\n}\n\nexport interface SegmentedProps {\n  /** Available options */\n  options: SegmentedOption[];\n  /** Selected value (controlled) */\n  value?: string;\n  /** Default selected value (uncontrolled) */\n  defaultValue?: string;\n  /** Change handler */\n  onChange?: (value: string) => void;\n  /** Size variant */\n  size?: 'sm' | 'md' | 'lg';\n  /** Full width */\n  block?: boolean;\n  /** Icon only mode */\n  iconOnly?: boolean;\n  /** Disabled state */\n  disabled?: boolean;\n  /** ARIA label */\n  'aria-label'?: string;\n  /** Custom className */\n  className?: string;\n}\n\n/**\n * Segmented Component\n *\n * Compact single-select button group, visual alternative to radio buttons.\n * Ideal for view mode switching, time range selection, and status filtering.\n *\n * @example\n * ```tsx\n * <Segmented\n *   options={[\n *     { value: 'list', label: 'List', icon: <List /> },\n *     { value: 'grid', label: 'Grid', icon: <Grid /> },\n *     { value: 'table', label: 'Table', icon: <Table /> },\n *   ]}\n *   defaultValue=\"list\"\n *   onChange={(value) => console.log(value)}\n * />\n * ```\n *\n * @example\n * ```tsx\n * // Icon only\n * <Segmented\n *   options={[\n *     { value: 'list', icon: <List />, label: 'List view' },\n *     { value: 'grid', icon: <Grid />, label: 'Grid view' },\n *   ]}\n *   iconOnly\n *   defaultValue=\"list\"\n * />\n * ```\n */\nexport const Segmented = ({\n  options,\n  value: controlledValue,\n  defaultValue,\n  onChange,\n  size = 'md',\n  block = false,\n  iconOnly = false,\n  disabled = false,\n  'aria-label': ariaLabel,\n  className,\n}: SegmentedProps) => {\n  // Handle controlled/uncontrolled state\n  const [uncontrolledValue, setUncontrolledValue] = useState<string>(\n    defaultValue || options[0]?.value || ''\n  );\n\n  const selectedValue = controlledValue !== undefined ? controlledValue : uncontrolledValue;\n\n  const handleChange = (newValue: string) => {\n    if (controlledValue === undefined) {\n      setUncontrolledValue(newValue);\n    }\n    onChange?.(newValue);\n  };\n\n  const containerClasses = [\n    styles.segmented,\n    size === 'sm' && styles.segmentedSm,\n    size === 'lg' && styles.segmentedLg,\n    block && styles.segmentedBlock,\n    iconOnly && styles.segmentedIconOnly,\n    disabled && styles.segmentedDisabled,\n    className,\n  ]\n    .filter(Boolean)\n    .join(' ');\n\n  return (\n    <div className={containerClasses} role=\"radiogroup\" aria-label={ariaLabel}>\n      {options.map((option) => {\n        const isSelected = selectedValue === option.value;\n        const isDisabled = disabled || option.disabled;\n        const inputId = `segmented-${option.value}-${Math.random().toString(36).substr(2, 9)}`;\n\n        return (\n          <div key={option.value}>\n            <input\n              type=\"radio\"\n              id={inputId}\n              name=\"segmented\"\n              value={option.value}\n              checked={isSelected}\n              disabled={isDisabled}\n              onChange={() => handleChange(option.value)}\n              hidden\n            />\n            <label\n              htmlFor={inputId}\n              className={styles.segmentedItem}\n              aria-label={iconOnly ? (typeof option.label === 'string' ? option.label : undefined) : undefined}\n            >\n              {option.icon && <span className={styles.segmentedItemIcon}>{option.icon}</span>}\n              {!iconOnly && option.label && <span>{option.label}</span>}\n            </label>\n          </div>\n        );\n      })}\n    </div>\n  );\n};\n\nSegmented.displayName = 'Segmented';\n"],"names":["Segmented","options","controlledValue","defaultValue","onChange","size","block","iconOnly","disabled","ariaLabel","className","uncontrolledValue","setUncontrolledValue","useState","selectedValue","handleChange","newValue","containerClasses","styles","jsx","option","isSelected","isDisabled","inputId","jsxs"],"mappings":"gLAsEaA,EAAY,CAAC,CACxB,QAAAC,EACA,MAAOC,EACP,aAAAC,EACA,SAAAC,EACA,KAAAC,EAAO,KACP,MAAAC,EAAQ,GACR,SAAAC,EAAW,GACX,SAAAC,EAAW,GACX,aAAcC,EACd,UAAAC,CACF,IAAsB,CAEpB,KAAM,CAACC,EAAmBC,CAAoB,EAAIC,EAAAA,SAChDV,GAAgBF,EAAQ,CAAC,GAAG,OAAS,EAAA,EAGjCa,EAAgBZ,IAAoB,OAAYA,EAAkBS,EAElEI,EAAgBC,GAAqB,CACrCd,IAAoB,QACtBU,EAAqBI,CAAQ,EAE/BZ,IAAWY,CAAQ,CACrB,EAEMC,EAAmB,CACvBC,EAAAA,QAAO,UACPb,IAAS,MAAQa,EAAAA,QAAO,YACxBb,IAAS,MAAQa,EAAAA,QAAO,YACxBZ,GAASY,EAAAA,QAAO,eAChBX,GAAYW,EAAAA,QAAO,kBACnBV,GAAYU,EAAAA,QAAO,kBACnBR,CAAA,EAEC,OAAO,OAAO,EACd,KAAK,GAAG,EAEX,OACES,EAAAA,IAAC,MAAA,CAAI,UAAWF,EAAkB,KAAK,aAAa,aAAYR,EAC7D,SAAAR,EAAQ,IAAKmB,GAAW,CACvB,MAAMC,EAAaP,IAAkBM,EAAO,MACtCE,EAAad,GAAYY,EAAO,SAChCG,EAAU,aAAaH,EAAO,KAAK,IAAI,KAAK,OAAA,EAAS,SAAS,EAAE,EAAE,OAAO,EAAG,CAAC,CAAC,GAEpF,cACG,MAAA,CACC,SAAA,CAAAD,EAAAA,IAAC,QAAA,CACC,KAAK,QACL,GAAII,EACJ,KAAK,YACL,MAAOH,EAAO,MACd,QAASC,EACT,SAAUC,EACV,SAAU,IAAMP,EAAaK,EAAO,KAAK,EACzC,OAAM,EAAA,CAAA,EAERI,EAAAA,KAAC,QAAA,CACC,QAASD,EACT,UAAWL,EAAAA,QAAO,cAClB,aAAYX,GAAY,OAAOa,EAAO,OAAU,SAAWA,EAAO,MAAqB,OAEtF,SAAA,CAAAA,EAAO,MAAQD,MAAC,OAAA,CAAK,UAAWD,EAAAA,QAAO,kBAAoB,WAAO,IAAA,CAAK,EACvE,CAACX,GAAYa,EAAO,OAASD,EAAAA,IAAC,OAAA,CAAM,WAAO,KAAA,CAAM,CAAA,CAAA,CAAA,CACpD,CAAA,EAlBQC,EAAO,KAmBjB,CAEJ,CAAC,CAAA,CACH,CAEJ,EAEApB,EAAU,YAAc"}