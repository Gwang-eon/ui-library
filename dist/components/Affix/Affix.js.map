{"version":3,"file":"Affix.js","sources":["../../../src/components/Affix/Affix.tsx"],"sourcesContent":["import { useState, useEffect, useRef, useCallback } from 'react';\nimport type { ReactNode, CSSProperties } from 'react';\nimport styles from './Affix.module.css';\n\nexport interface AffixProps {\n  /** Content to be affixed */\n  children: ReactNode;\n  /** Offset from top when affixed (in pixels) */\n  offsetTop?: number;\n  /** Offset from bottom when affixed (in pixels) */\n  offsetBottom?: number;\n  /** Target container ID to affix within (defaults to window) */\n  target?: string;\n  /** Callback when affix state changes */\n  onChange?: (affixed: boolean) => void;\n  /** Additional CSS classes */\n  className?: string;\n  /** Custom z-index for affixed element */\n  zIndex?: number;\n  /** Additional inline styles */\n  style?: CSSProperties;\n}\n\n/**\n * Affix component - Makes an element stick to viewport or container on scroll\n *\n * Features:\n * - Window or container-based affixing\n * - Top or bottom positioning\n * - Custom offset configuration\n * - Placeholder maintains layout when affixed\n * - Smooth transitions\n * - Responsive behavior\n *\n * @example\n * ```tsx\n * <Affix offsetTop={64}>\n *   <Toolbar />\n * </Affix>\n * ```\n */\nexport const Affix = ({\n  children,\n  offsetTop,\n  offsetBottom,\n  target,\n  onChange,\n  className = '',\n  zIndex = 100,\n  style = {},\n}: AffixProps) => {\n  const [affixed, setAffixed] = useState(false);\n  const affixRef = useRef<HTMLDivElement>(null);\n  const placeholderRef = useRef<HTMLDivElement>(null);\n  const [affixStyle, setAffixStyle] = useState<CSSProperties>({});\n  const [placeholderStyle, setPlaceholderStyle] = useState<CSSProperties>({\n    display: 'none',\n    height: 0,\n    margin: 0,\n    padding: 0,\n  });\n\n  // Use refs to track state without causing re-renders\n  const affixedRef = useRef(false);\n  const measurementsRef = useRef({\n    originalOffsetTop: 0,\n    originalOffsetLeft: 0,\n    elementWidth: 0,\n    elementHeight: 0,\n  });\n  const rafIdRef = useRef<number | null>(null);\n\n  // Validate props\n  const hasTop = offsetTop !== undefined;\n  const hasBottom = offsetBottom !== undefined;\n\n  if (hasTop && hasBottom) {\n    console.warn('Affix: Both offsetTop and offsetBottom are set. Using offsetTop.');\n  }\n\n  const offset = hasTop ? offsetTop : offsetBottom;\n  const position = hasTop ? 'top' : 'bottom';\n\n  // Measure element dimensions and position\n  const updateMeasurements = useCallback(() => {\n    const affixElement = affixRef.current;\n    const placeholderElement = placeholderRef.current;\n    if (!affixElement || !placeholderElement) return;\n\n    const scrollContainer = target ? document.getElementById(target) : window;\n    if (!scrollContainer) return;\n\n    const rect = affixElement.getBoundingClientRect();\n    const scrollTop = scrollContainer === window ? window.scrollY : (scrollContainer as HTMLElement).scrollTop;\n    const scrollLeft = scrollContainer === window ? window.scrollX : (scrollContainer as HTMLElement).scrollLeft;\n\n    measurementsRef.current = {\n      originalOffsetTop: rect.top + scrollTop,\n      originalOffsetLeft: rect.left + scrollLeft,\n      elementWidth: rect.width,\n      elementHeight: rect.height,\n    };\n  }, [target]);\n\n  // Throttled scroll handler using requestAnimationFrame\n  const handleScroll = useCallback(() => {\n    if (rafIdRef.current !== null) return;\n\n    rafIdRef.current = requestAnimationFrame(() => {\n      rafIdRef.current = null;\n\n      const affixElement = affixRef.current;\n      if (!affixElement) return;\n\n      const scrollContainer = target ? document.getElementById(target) : window;\n      if (!scrollContainer) return;\n\n      const scrollTop = scrollContainer === window\n        ? window.scrollY\n        : (scrollContainer as HTMLElement).scrollTop;\n\n      const viewportHeight = scrollContainer === window\n        ? window.innerHeight\n        : (scrollContainer as HTMLElement).clientHeight;\n\n      const { originalOffsetTop, originalOffsetLeft, elementWidth, elementHeight } = measurementsRef.current;\n      let shouldAffix = false;\n\n      if (position === 'top') {\n        // Top affixing\n        const offsetValue = offset ?? 0;\n        shouldAffix = scrollTop > originalOffsetTop - offsetValue;\n\n        if (shouldAffix && !affixedRef.current) {\n          // Activate affix\n          affixedRef.current = true;\n          setAffixed(true);\n          setPlaceholderStyle({\n            display: 'block',\n            height: `${elementHeight}px`,\n            width: `${elementWidth}px`,\n            margin: 0,\n            padding: 0,\n            border: 'none',\n          });\n          setAffixStyle({\n            position: 'fixed',\n            top: `${offsetValue}px`,\n            left: `${originalOffsetLeft}px`,\n            width: `${elementWidth}px`,\n            zIndex,\n          });\n          onChange?.(true);\n        } else if (!shouldAffix && affixedRef.current) {\n          // Deactivate affix\n          affixedRef.current = false;\n          setAffixed(false);\n          setPlaceholderStyle({\n            display: 'none',\n            height: 0,\n            margin: 0,\n            padding: 0,\n          });\n          setAffixStyle({});\n          onChange?.(false);\n        }\n      } else {\n        // Bottom affixing\n        const offsetValue = offset ?? 0;\n        const elementBottom = originalOffsetTop + elementHeight;\n        const viewportBottom = scrollTop + viewportHeight;\n        shouldAffix = viewportBottom < elementBottom + offsetValue;\n\n        if (shouldAffix && !affixedRef.current) {\n          // Activate affix\n          affixedRef.current = true;\n          setAffixed(true);\n          setPlaceholderStyle({\n            display: 'block',\n            height: `${elementHeight}px`,\n            width: `${elementWidth}px`,\n            margin: 0,\n            padding: 0,\n            border: 'none',\n          });\n          setAffixStyle({\n            position: 'fixed',\n            bottom: `${offsetValue}px`,\n            left: `${originalOffsetLeft}px`,\n            width: `${elementWidth}px`,\n            zIndex,\n          });\n          onChange?.(true);\n        } else if (!shouldAffix && affixedRef.current) {\n          // Deactivate affix\n          affixedRef.current = false;\n          setAffixed(false);\n          setPlaceholderStyle({\n            display: 'none',\n            height: 0,\n            margin: 0,\n            padding: 0,\n          });\n          setAffixStyle({});\n          onChange?.(false);\n        }\n      }\n    });\n  }, [offset, position, target, zIndex, onChange]);\n\n  // Handle resize with measurement update\n  const handleResize = useCallback(() => {\n    // Only update measurements when not affixed to prevent jumping\n    if (!affixedRef.current) {\n      updateMeasurements();\n    }\n    handleScroll();\n  }, [updateMeasurements, handleScroll]);\n\n  // Initial measurements\n  useEffect(() => {\n    updateMeasurements();\n  }, [updateMeasurements]);\n\n  // Setup scroll and resize listeners\n  useEffect(() => {\n    const scrollContainer = target ? document.getElementById(target) : window;\n\n    if (!scrollContainer) {\n      if (target) {\n        console.warn(`Affix: Target container with id \"${target}\" not found.`);\n      }\n      return;\n    }\n\n    // Initial check\n    handleScroll();\n\n    // Add event listeners\n    if (scrollContainer === window) {\n      window.addEventListener('scroll', handleScroll, { passive: true });\n      window.addEventListener('resize', handleResize);\n    } else {\n      scrollContainer.addEventListener('scroll', handleScroll, { passive: true });\n      window.addEventListener('resize', handleResize);\n    }\n\n    // Cleanup\n    return () => {\n      if (rafIdRef.current !== null) {\n        cancelAnimationFrame(rafIdRef.current);\n      }\n\n      if (scrollContainer === window) {\n        window.removeEventListener('scroll', handleScroll);\n        window.removeEventListener('resize', handleResize);\n      } else {\n        scrollContainer.removeEventListener('scroll', handleScroll);\n        window.removeEventListener('resize', handleResize);\n      }\n    };\n  }, [offset, position, target, zIndex, handleScroll, handleResize]);\n\n  return (\n    <>\n      {/* Affixed element */}\n      <div\n        ref={affixRef}\n        className={`${styles.affix} ${affixed ? styles.affixActive : ''} ${className}`}\n        style={{ ...affixStyle, ...style }}\n        data-affixed={affixed}\n      >\n        {children}\n      </div>\n\n      {/* Placeholder to maintain layout when affixed - always rendered to maintain ref */}\n      <div\n        ref={placeholderRef}\n        style={placeholderStyle}\n        aria-hidden=\"true\"\n        className={styles.affixPlaceholder}\n      />\n    </>\n  );\n};\n"],"names":["Affix","children","offsetTop","offsetBottom","target","onChange","className","zIndex","style","affixed","setAffixed","useState","affixRef","useRef","placeholderRef","affixStyle","setAffixStyle","placeholderStyle","setPlaceholderStyle","affixedRef","measurementsRef","rafIdRef","hasTop","offset","position","updateMeasurements","useCallback","affixElement","placeholderElement","scrollContainer","rect","scrollTop","scrollLeft","handleScroll","viewportHeight","originalOffsetTop","originalOffsetLeft","elementWidth","elementHeight","shouldAffix","offsetValue","elementBottom","handleResize","useEffect","jsxs","Fragment","jsx","styles"],"mappings":"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"}