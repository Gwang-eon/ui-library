{"version":3,"file":"Anchor.cjs","sources":["../../../src/components/Anchor/Anchor.tsx"],"sourcesContent":["import { useState, useEffect, useRef, useCallback } from 'react';\nimport type { ReactNode } from 'react';\nimport styles from './Anchor.module.css';\n\nexport interface AnchorItem {\n  /** Unique key for the anchor item */\n  key: string;\n  /** Display title for the anchor link */\n  title: ReactNode;\n  /** Target href (must start with #) */\n  href: string;\n  /** Optional icon before the title */\n  icon?: ReactNode;\n  /** Optional nested anchor items */\n  children?: AnchorItem[];\n}\n\nexport interface AnchorProps {\n  /** Array of anchor items to display */\n  items: AnchorItem[];\n  /** Active anchor key (controlled mode) */\n  activeKey?: string;\n  /** Offset from top when scrolling to section (in pixels) */\n  offsetTop?: number;\n  /** Enable sticky positioning */\n  sticky?: boolean;\n  /** Callback when active section changes */\n  onChange?: (activeKey: string) => void;\n  /** Additional CSS classes */\n  className?: string;\n  /** Root margin for Intersection Observer (default: '-20% 0px -80% 0px') */\n  rootMargin?: string;\n  /** Smooth scroll behavior */\n  smooth?: boolean;\n}\n\n/**\n * Anchor component - Hyperlinks to scroll on one page\n *\n * Features:\n * - Automatic scroll highlighting using Intersection Observer\n * - Smooth scroll on click\n * - Support for nested anchor links\n * - Keyboard accessible (Arrow keys, Home, End)\n * - Sticky positioning option\n *\n * @example\n * ```tsx\n * <Anchor\n *   items={[\n *     { key: 'overview', title: 'Overview', href: '#overview' },\n *     { key: 'config', title: 'Configuration', href: '#config' }\n *   ]}\n *   sticky\n *   offsetTop={80}\n * />\n * ```\n */\nexport const Anchor = ({\n  items,\n  activeKey: controlledActiveKey,\n  offsetTop = 60,\n  sticky = false,\n  onChange,\n  className = '',\n  rootMargin = '-20% 0px -80% 0px',\n  smooth = true,\n}: AnchorProps) => {\n  const [activeKey, setActiveKey] = useState<string>('');\n  const anchorRef = useRef<HTMLElement>(null);\n  const linksRef = useRef<Map<string, HTMLAnchorElement>>(new Map());\n  const observerRef = useRef<IntersectionObserver | null>(null);\n\n  // Use controlled or uncontrolled active key\n  const currentActiveKey = controlledActiveKey !== undefined ? controlledActiveKey : activeKey;\n\n  // Flatten items to get all keys and hrefs\n  const flattenItems = useCallback((items: AnchorItem[]): AnchorItem[] => {\n    return items.reduce((acc: AnchorItem[], item) => {\n      acc.push(item);\n      if (item.children) {\n        acc.push(...flattenItems(item.children));\n      }\n      return acc;\n    }, []);\n  }, []);\n\n  const allItems = flattenItems(items);\n\n  // Set up Intersection Observer for scroll detection\n  useEffect(() => {\n    if (allItems.length === 0) return;\n\n    const sections: HTMLElement[] = [];\n\n    // Find all target sections\n    allItems.forEach((item) => {\n      const targetId = item.href.substring(1);\n      const section = document.getElementById(targetId);\n      if (section) {\n        sections.push(section);\n      }\n    });\n\n    if (sections.length === 0) return;\n\n    // Create Intersection Observer\n    const observerOptions: IntersectionObserverInit = {\n      rootMargin,\n      threshold: [0, 0.25, 0.5, 0.75, 1],\n    };\n\n    // Track which sections are currently visible\n    const visibleSections = new Set<string>();\n\n    observerRef.current = new IntersectionObserver((entries) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          visibleSections.add(entry.target.id);\n        } else {\n          visibleSections.delete(entry.target.id);\n        }\n      });\n\n      // Get the topmost visible section\n      if (visibleSections.size > 0) {\n        const firstVisible = sections.find((section) =>\n          visibleSections.has(section.id)\n        );\n        if (firstVisible) {\n          const foundItem = allItems.find(\n            (item) => item.href === '#' + firstVisible.id\n          );\n          if (foundItem) {\n            const newActiveKey = foundItem.key;\n            if (controlledActiveKey === undefined) {\n              setActiveKey(newActiveKey);\n            }\n            onChange?.(newActiveKey);\n          }\n        }\n      }\n    }, observerOptions);\n\n    // Observe all sections\n    sections.forEach((section) => {\n      observerRef.current?.observe(section);\n    });\n\n    // Cleanup\n    return () => {\n      if (observerRef.current) {\n        sections.forEach((section) => {\n          observerRef.current?.unobserve(section);\n        });\n        observerRef.current.disconnect();\n      }\n    };\n  }, [allItems, rootMargin, onChange, controlledActiveKey]);\n\n  // Handle anchor link click\n  const handleClick = useCallback(\n    (e: React.MouseEvent<HTMLAnchorElement>, item: AnchorItem) => {\n      e.preventDefault();\n\n      const targetId = item.href.substring(1);\n      const targetSection = document.getElementById(targetId);\n\n      if (targetSection) {\n        // Calculate offset\n        const yOffset = -offsetTop;\n        const y =\n          targetSection.getBoundingClientRect().top +\n          window.pageYOffset +\n          yOffset;\n\n        // Scroll to target\n        window.scrollTo({\n          top: y,\n          behavior: smooth ? 'smooth' : 'auto',\n        });\n\n        // Update URL hash without jumping\n        if (history.pushState) {\n          history.pushState(null, '', item.href);\n        }\n\n        // Update active state\n        if (controlledActiveKey === undefined) {\n          setActiveKey(item.key);\n        }\n        onChange?.(item.key);\n      }\n    },\n    [offsetTop, smooth, controlledActiveKey, onChange]\n  );\n\n  // Keyboard navigation\n  const handleKeyDown = useCallback(\n    (e: React.KeyboardEvent<HTMLAnchorElement>, currentIndex: number) => {\n      const allLinks = Array.from(linksRef.current.values());\n      let targetIndex: number;\n\n      switch (e.key) {\n        case 'ArrowDown':\n          e.preventDefault();\n          targetIndex = Math.min(currentIndex + 1, allLinks.length - 1);\n          allLinks[targetIndex]?.focus();\n          break;\n        case 'ArrowUp':\n          e.preventDefault();\n          targetIndex = Math.max(currentIndex - 1, 0);\n          allLinks[targetIndex]?.focus();\n          break;\n        case 'Home':\n          e.preventDefault();\n          allLinks[0]?.focus();\n          break;\n        case 'End':\n          e.preventDefault();\n          allLinks[allLinks.length - 1]?.focus();\n          break;\n      }\n    },\n    []\n  );\n\n  // Render anchor item\n  const renderAnchorItem = (item: AnchorItem, index: number) => {\n    const isActive = currentActiveKey === item.key;\n\n    return (\n      <div key={item.key} className={styles.anchorItem}>\n        <a\n          href={item.href}\n          ref={(el) => {\n            if (el) {\n              linksRef.current.set(item.key, el);\n            } else {\n              linksRef.current.delete(item.key);\n            }\n          }}\n          className={`${styles.anchorLink} ${isActive ? styles.active : ''}`}\n          onClick={(e) => handleClick(e, item)}\n          onKeyDown={(e) => handleKeyDown(e, index)}\n          aria-current={isActive ? 'location' : undefined}\n        >\n          {item.icon && <span className={styles.anchorIcon}>{item.icon}</span>}\n          <span>{item.title}</span>\n        </a>\n\n        {/* Render nested items */}\n        {item.children && item.children.length > 0 && (\n          <div className={styles.anchorSubmenu}>\n            {item.children.map((child, childIndex) =>\n              renderAnchorItem(child, index + childIndex + 1)\n            )}\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  return (\n    <nav\n      ref={anchorRef}\n      className={`${styles.anchor} ${sticky ? styles.sticky : ''} ${className}`}\n      role=\"navigation\"\n      aria-label=\"Page navigation\"\n    >\n      {items.map((item, index) => renderAnchorItem(item, index))}\n    </nav>\n  );\n};\n"],"names":["Anchor","items","controlledActiveKey","offsetTop","sticky","onChange","className","rootMargin","smooth","activeKey","setActiveKey","useState","anchorRef","useRef","linksRef","observerRef","currentActiveKey","flattenItems","useCallback","acc","item","allItems","useEffect","sections","targetId","section","observerOptions","visibleSections","entries","entry","firstVisible","foundItem","newActiveKey","handleClick","targetSection","yOffset","y","handleKeyDown","currentIndex","allLinks","targetIndex","renderAnchorItem","index","isActive","jsxs","styles","el","e","jsx","child","childIndex"],"mappings":"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"}