{"version":3,"file":"CascadeSelect.js","sources":["../../../src/components/CascadeSelect/CascadeSelect.tsx"],"sourcesContent":["import React, { useState, useRef, useEffect, type HTMLAttributes } from 'react';\nimport { ChevronDown, ChevronRight } from 'lucide-react';\nimport styles from './CascadeSelect.module.css';\n\nexport interface CascadeOption {\n  /**\n   * Option label\n   */\n  label: string;\n\n  /**\n   * Option value\n   */\n  value: string;\n\n  /**\n   * Child options for nested selection\n   */\n  children?: CascadeOption[];\n\n  /**\n   * Disabled state\n   */\n  disabled?: boolean;\n}\n\nexport interface CascadeSelectProps extends Omit<HTMLAttributes<HTMLDivElement>, 'onChange'> {\n  /**\n   * Hierarchical options data\n   */\n  options: CascadeOption[];\n\n  /**\n   * Selected value path (array of values from root to leaf)\n   */\n  value?: string[];\n\n  /**\n   * Change handler - receives array of selected values\n   */\n  onChange?: (value: string[], labels: string[]) => void;\n\n  /**\n   * Placeholder text\n   */\n  placeholder?: string;\n\n  /**\n   * Disabled state\n   */\n  disabled?: boolean;\n\n  /**\n   * Additional CSS class\n   */\n  className?: string;\n}\n\n/**\n * CascadeSelect component for hierarchical data selection\n *\n * @example\n * ```tsx\n * const locations = [\n *   {\n *     label: 'Building A',\n *     value: 'building-a',\n *     children: [\n *       { label: 'Floor 1', value: 'floor-1', children: [...] }\n *     ]\n *   }\n * ];\n *\n * <CascadeSelect\n *   options={locations}\n *   value={['building-a', 'floor-1', 'zone-a']}\n *   onChange={(values, labels) => console.log(values, labels)}\n *   placeholder=\"Select location...\"\n * />\n * ```\n */\nexport const CascadeSelect: React.FC<CascadeSelectProps> = ({\n  options,\n  value = [],\n  onChange,\n  placeholder = 'Select...',\n  disabled = false,\n  className = '',\n  ...rest\n}) => {\n  const [isOpen, setIsOpen] = useState(false);\n  const [selectedPath, setSelectedPath] = useState<string[]>(value);\n  const [hoveredPath, setHoveredPath] = useState<string[]>([]);\n  const [hoveredOptionRefs, setHoveredOptionRefs] = useState<Map<number, HTMLDivElement>>(new Map());\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  // Close dropdown when clicking outside\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (containerRef.current && !containerRef.current.contains(event.target as Node)) {\n        setIsOpen(false);\n        setHoveredPath([]);\n        setHoveredOptionRefs(new Map());\n      }\n    };\n\n    if (isOpen) {\n      document.addEventListener('mousedown', handleClickOutside);\n    }\n\n    return () => {\n      document.removeEventListener('mousedown', handleClickOutside);\n    };\n  }, [isOpen]);\n\n  // Get display text from selected path\n  const getDisplayText = () => {\n    if (selectedPath.length === 0) return placeholder;\n\n    const labels: string[] = [];\n    let currentOptions = options;\n\n    for (const val of selectedPath) {\n      const option = currentOptions.find((opt) => opt.value === val);\n      if (option) {\n        labels.push(option.label);\n        currentOptions = option.children || [];\n      }\n    }\n\n    return labels.join(' / ');\n  };\n\n  // Get options for a specific level based on hovered or selected path\n  const getOptionsForLevel = (level: number): CascadeOption[] => {\n    if (level === 0) return options;\n\n    // Use hoveredPath if available, otherwise use selectedPath\n    const pathToUse = hoveredPath.length >= level ? hoveredPath : selectedPath;\n\n    let currentOptions = options;\n    for (let i = 0; i < level; i++) {\n      const val = pathToUse[i];\n      if (!val) return [];\n\n      const option = currentOptions.find((opt) => opt.value === val);\n      if (option?.children) {\n        currentOptions = option.children;\n      } else {\n        return [];\n      }\n    }\n\n    return currentOptions;\n  };\n\n  // Calculate how many levels should be visible\n  const getVisibleLevels = (): number => {\n    // Start with level 0 (always visible)\n    let levels = 1;\n\n    // Use hoveredPath if hovering, otherwise use selectedPath\n    const pathToCheck = hoveredPath.length > 0 ? hoveredPath : selectedPath;\n\n    let currentOptions = options;\n    for (const val of pathToCheck) {\n      const option = currentOptions.find((opt) => opt.value === val);\n      if (option?.children && option.children.length > 0) {\n        levels++;\n        currentOptions = option.children;\n      } else {\n        break;\n      }\n    }\n\n    return levels;\n  };\n\n  // Handle option hover\n  const handleOptionHover = (option: CascadeOption, level: number, element: HTMLDivElement | null) => {\n    if (option.disabled) return;\n\n    // Build the new hover path up to this level\n    const newPath = [\n      ...hoveredPath.slice(0, level),\n      option.value\n    ];\n\n    setHoveredPath(newPath);\n\n    // Store the hovered element reference for positioning\n    if (element) {\n      setHoveredOptionRefs(prev => {\n        const next = new Map(prev);\n        next.set(level, element);\n        return next;\n      });\n    }\n  };\n\n  // Handle option click\n  const handleOptionClick = (option: CascadeOption, level: number) => {\n    if (option.disabled) return;\n\n    // Build the path up to this level\n    const newPath = [\n      ...hoveredPath.slice(0, level),\n      option.value\n    ];\n\n    // If this is a leaf node (no children), complete the selection\n    if (!option.children || option.children.length === 0) {\n      setSelectedPath(newPath);\n      setIsOpen(false);\n      setHoveredPath([]);\n      setHoveredOptionRefs(new Map());\n\n      // Build labels array\n      const labels: string[] = [];\n      let currentOptions = options;\n      for (const val of newPath) {\n        const opt = currentOptions.find((o) => o.value === val);\n        if (opt) {\n          labels.push(opt.label);\n          currentOptions = opt.children || [];\n        }\n      }\n\n      onChange?.(newPath, labels);\n    } else {\n      // If has children, just update hover state (already done by hover handler)\n      setHoveredPath(newPath);\n    }\n  };\n\n  // Check if option is in selected path\n  const isSelected = (optionValue: string, level: number): boolean => {\n    return selectedPath[level] === optionValue;\n  };\n\n  // Check if option is in hovered path\n  const isActive = (optionValue: string, level: number): boolean => {\n    return hoveredPath[level] === optionValue;\n  };\n\n  const containerClasses = [\n    styles['cascade-select'],\n    isOpen && styles.open,\n    disabled && styles.disabled,\n    className,\n  ]\n    .filter(Boolean)\n    .join(' ');\n\n  const triggerClasses = [\n    styles['cascade-trigger'],\n    selectedPath.length === 0 && styles.placeholder,\n  ]\n    .filter(Boolean)\n    .join(' ');\n\n  const visibleLevels = isOpen ? getVisibleLevels() : 0;\n\n  return (\n    <div ref={containerRef} className={containerClasses} {...rest}>\n      {/* Trigger Button */}\n      <button\n        type=\"button\"\n        className={triggerClasses}\n        onClick={() => !disabled && setIsOpen(!isOpen)}\n        disabled={disabled}\n        aria-haspopup=\"listbox\"\n        aria-expanded={isOpen}\n      >\n        {getDisplayText()}\n        <ChevronDown className={styles['select-icon']} size={18} />\n      </button>\n\n      {/* Dropdown Panel */}\n      {isOpen && (\n        <div className={styles['cascade-panel']}>\n          {Array.from({ length: visibleLevels }).map((_, level) => {\n            const levelOptions = getOptionsForLevel(level);\n            if (levelOptions.length === 0) return null;\n\n            const subpanelClasses = [\n              styles['cascade-subpanel'],\n              level > 0 && styles.nested,\n              level > 0 && styles.show,\n            ]\n              .filter(Boolean)\n              .join(' ');\n\n            // Calculate top position based on the hovered option in the previous level\n            let topOffset = 0;\n            if (level > 0) {\n              const hoveredElement = hoveredOptionRefs.get(level - 1);\n              if (hoveredElement) {\n                topOffset = hoveredElement.offsetTop;\n              }\n            }\n\n            const subpanelStyle: React.CSSProperties =\n              level > 0\n                ? {\n                    position: 'absolute',\n                    left: `${level * 100}%`,\n                    top: topOffset,\n                  }\n                : {};\n\n            return (\n              <div key={level} className={subpanelClasses} style={subpanelStyle}>\n                {levelOptions.map((option) => {\n                  const hasChildren = option.children && option.children.length > 0;\n                  const optionClasses = [\n                    styles['cascade-option'],\n                    isSelected(option.value, level) && styles.selected,\n                    isActive(option.value, level) && styles.active,\n                    option.disabled && styles.disabled,\n                  ]\n                    .filter(Boolean)\n                    .join(' ');\n\n                  return (\n                    <div\n                      key={option.value}\n                      className={optionClasses}\n                      onClick={() => handleOptionClick(option, level)}\n                      onMouseEnter={(e) => handleOptionHover(option, level, e.currentTarget)}\n                      role=\"option\"\n                      aria-selected={isSelected(option.value, level)}\n                      aria-disabled={option.disabled}\n                    >\n                      <span>{option.label}</span>\n                      {hasChildren && <ChevronRight className={styles['option-arrow']} size={16} />}\n                    </div>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      )}\n    </div>\n  );\n};\n\nCascadeSelect.displayName = 'CascadeSelect';\n\nexport default CascadeSelect;\n"],"names":["CascadeSelect","options","value","onChange","placeholder","disabled","className","rest","isOpen","setIsOpen","useState","selectedPath","setSelectedPath","hoveredPath","setHoveredPath","hoveredOptionRefs","setHoveredOptionRefs","containerRef","useRef","useEffect","handleClickOutside","event","getDisplayText","labels","currentOptions","val","option","opt","getOptionsForLevel","level","pathToUse","i","getVisibleLevels","levels","pathToCheck","handleOptionHover","element","newPath","prev","next","handleOptionClick","o","isSelected","optionValue","isActive","containerClasses","styles","triggerClasses","visibleLevels","jsxs","ChevronDown","jsx","_","levelOptions","subpanelClasses","topOffset","hoveredElement","subpanelStyle","hasChildren","optionClasses","e","ChevronRight"],"mappings":"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"}